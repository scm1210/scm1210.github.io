---
title: "I-Projection Results"
author: "Steven"
date: "`r Sys.Date()`"
format: 
  revealjs:
    css: styles.css
    center: true  
    scrollable: true
    smaller: true
    controls: true
    progress: true
    keyboard: true
    slide-number: true 
    slideNumberFormat: "%current% / %total%"
    navigationMode: 'linear'
    transition: "slide"
    transitionSpeed: "fast"
    touch: true  
execute:
  fig-width: 5
  fig-height: 3
---

```{r load packages and installize conda environment, include=FALSE}
if (!require("pacman")) install.packages("pacman") #run this if you don't have pacman 
library(pacman)
pacman::p_load(tidyverse,DT,lmerTest,
               lme4,reactable,
               broom.mixed,knitr,
               kableExtra,ggrepel,
               ggeffects,patchwork,
               install = T) 

good_palette <- c(
  "#772e25", "#c44536", "#ee9b00", "#197278", "#283d3b", 
  "#9CC5A1", "#6195C6", "#ADA7C9", "#4D4861", "grey50",
  "#d4a373", "#8a5a44", "#4a6a74", "#5c80a8", "#a9c5a0",
  "#7b9b8e", "#e1b16a", "#a69b7c", "#9d94c4", "#665c54"
)

palette_condition = c("#ee9b00", "#c44536","#005f73", "#283d3b", "#9CC5A1", "#6195C6", "#ADA7C9", "#4D4861")
plot_aes = theme_minimal() +
  theme(legend.position = "none",
        legend.text = element_text(size = 12),
        text = element_text(size = 16, family = "Futura Medium"),
        axis.text = element_text(color = "black"),
        axis.ticks.y = element_blank())

```

```{r helper functions}
table_model <- function(model, reference = "Intercept", dv_name = "dependent_variable") {
  # Extract the tidy data from the model directly
  model_data <- tidy(model, conf.int = TRUE)
  
  # Process the model data
  model_table <- model_data %>%
    filter(effect == "fixed") %>%
    rename("SE" = std.error,
           "t" = statistic,
           "p" = p.value) %>%
    select(-group, -effect) %>%
    mutate(across(where(is.numeric), ~round(., 5))) %>%
    mutate(
      term = gsub("\\(Intercept\\)", !!reference, term),
      term = gsub(":", " x ", term),
      term = gsub("ethnicity", "", term),
      p_original = p,
      p = ifelse(p < .001, "< .001",
                 ifelse(p == 1, "1.000", gsub("0.(.*)", ".\\1", sprintf("%.3f", p)))),
      `b [95% CI]` = sprintf("%.4f [%0.4f, %.4f]", estimate, conf.low, conf.high),  # Changed estimate to 4 decimal places
      significance = case_when(
        p_original < 0.001 ~ "***",
        p_original < 0.01 ~ "**",
        p_original < 0.05 ~ "*",
        p_original < 0.10 ~ "+",
        TRUE ~ ""
      )
    ) %>%
    select(term, `b [95% CI]`, df, SE, t, p, significance)
  
  # Create a datatable for displaying results
  dt_table <- datatable(
    model_table,
    caption = htmltools::tags$caption(
      style = 'caption-side: top; text-align: center; color: black; font-size: 20px; font-weight: bold;',
      paste('Linear Mixed Model Results for', dv_name)  # Dynamic DV in caption
    ),
    options = list(
      pageLength = 20,
      dom = 't',
      columnDefs = list(list(className = 'dt-center', targets = 1:5))
    ),
    rownames = FALSE
  ) %>%
    formatStyle(
      'term',
      fontWeight = 'bold'
    ) %>%
    formatStyle(
      'p',
      color = styleInterval(c(0.001, 0.01, 0.05), c('darkred', 'red', 'orange', 'black'))
    )
  
  return(dt_table)
}


extract_lmer_data <- function(model) {
  # Ensure the broom.mixed package is available
  if (!requireNamespace("broom.mixed", quietly = TRUE)) {
    stop("Please install the 'broom.mixed' package to use this function.")
  }
  
  # Extract fixed effects with 95% confidence intervals
  fixed_effects <- broom.mixed::tidy(model, effects = "fixed", conf.int = TRUE)
  
  # Add the 'outcome' column with the value "Internalizing"
  fixed_effects <- fixed_effects %>%
    dplyr::mutate(outcome = "Internalizing")
  
  return(fixed_effects)
}

palette_counter <- 1  # start index

run_lmer_and_plot <- function(data, dv, iv = "daysSinceFirstText", group_var = "room_id",
                              title = "Change in Projection Over Time", ylab = "Projection") {
  # Use color from palette and increment counter
  color <- good_palette[palette_counter]
  palette_counter <<- ifelse(palette_counter < length(good_palette), 
                             palette_counter + 1, 1)  # cycle back to start
  
  formula <- as.formula(paste(dv, "~", iv, "+ (1|", group_var, ")"))
  
  model <- lmer(formula, data = data)
  
  # Predictions
  pred <- ggpredict(model, terms = iv)
  
  # Line + ribbon plot
  plot1 <- ggplot() +
  geom_line(data = data,
              aes_string(x = iv, y = dv, group = group_var),
              color = color, alpha = 0.01) +
 geom_line(data = pred, aes(x = x, y = predicted),
            color = color, size = 1.05, inherit.aes = FALSE) +
    geom_ribbon(data = pred,
                aes(x = x, ymin = conf.low, ymax = conf.high),
                fill = color, alpha = 0.2) +
    labs(
      title = title,
      x = iv,
      y = ylab
    ) + plot_aes
  
  # Spline-only plot
  plot2 <- ggplot(data, aes_string(x = iv, y = dv)) +
    geom_smooth(method = "gam", formula = y ~ s(x, k = 5),
                color = color, fill = color, alpha = 0.2) +
    labs(
      title = paste(title, "\n(Spline Fit)"),
      x = iv,
      y = ylab
    ) + plot_aes
  
  return(list(model = model, pred = pred, plot_line = plot1, plot_spline = plot2, color = color))
}

```

```{r}
#| label: load-data
#| include: false
data = read_csv("/Users/sm9518/Library/CloudStorage/Box-Box/Talkspace_ErikNook_HarvardPrinceton/Data/Processed/Mesquiti_LBA_2024/Talkspace-LBA/I-representations/data/text-level/MADS_roberta_results_Indy_am_v_feel.csv")
data = data %>%
  rename(
    Internalizing = internalizing,
    daysSinceFirstText = days_since_first_text
  ) %>% 
  filter(bin < 5)  %>% 
  mutate(
    # Recode Llama_rating_4: 1 = "Preamble", else "Not Preamble"
    Llama_rating_4 = ifelse(Llama_rating_4 == 1, "Preamble", "Not Preamble"),
    Llama_rating_4 = factor(Llama_rating_4, levels = c("Not Preamble", "Preamble")),
    
    # Recode Llama_rating similarly if needed
    Llama_rating = ifelse(Llama_rating == 1, "Preamble", "Not Preamble"),
    Llama_rating = factor(Llama_rating, levels = c("Not Preamble", "Preamble")) ,
    first_person_sing_valence_am = rowMeans(select(., I_projection_valence_am, me_projection_valence_am, my_projection_valence_am), na.rm = TRUE),
    first_person_sing_valence_feel = rowMeans(select(., I_projection_valence_feel, me_projection_valence_feel, my_projection_valence_feel), na.rm = TRUE),
    first_person_sing_valence_combined = rowMeans(select(., I_projection_valence_combined, me_projection_valence_combined, my_projection_valence_combined), na.rm = TRUE),
    first_person_sing_ability_am = rowMeans(select(., I_projection_ability_am, me_projection_ability_am, my_projection_ability_am), na.rm = TRUE),
    first_person_sing_ability_feel = rowMeans(select(., I_projection_ability_feel, me_projection_ability_feel, my_projection_ability_feel), na.rm = TRUE),
    first_person_sing_ability_combined = rowMeans(select(., I_projection_ability_combined, me_projection_ability_combined, my_projection_ability_combined), na.rm = TRUE)
    )


good_bad_data_small =  data |> 
  group_by(room_id,daysSinceFirstText) %>%
  summarise(across(
    where(is.numeric),
    mean,
    na.rm = TRUE
  ), .groups = "drop") |> 
  filter(n_total > 20)

```

# Overview

## Under the hood

***What this analysis does***

-   Loads a RoBERTa (a LLM) to embed participant text into high-dimensional vectors.

-   Defines psychological axes (valence, ability) using controlled “I am” / “I feel” statements; each axis is the normalized difference between mean embeddings of positive vs. negative statements.

-   This allows us to capture the psychological dimensions of interest in the embedding space (i.e., good-bad and able-unable).

-   Projects target words (e.g., I, me, my) onto these axes by computing the dot product between each word’s embedding and the axis vector, capturing how strongly that word aligns with a psychological dimension.

-   Aggregates these projections at the text level to create text-level measures of valence and ability projections for each participant, which we can then use for down-stream analyses.

# I Change over time (am, feel, & combined)

*Note.* Data are aggregated at the assessment level and coefficients are unstandardized

------------------------------------------------------------------------

## I_projection_valence_am

```{r}
res1 <- run_lmer_and_plot(good_bad_data_small, dv = "I_projection_valence_am")
res1$model %>% table_model(dv_name = "I_projection_valence_am")
```

------------------------------------------------------------------------

### I_projection_valence_am individual variation

```{r}
res1$plot_line
```

------------------------------------------------------------------------

### I_projection_valence_am spline fit

```{r}
res1$plot_spline
```

------------------------------------------------------------------------

## I_projection_valence_feel

```{r}
res2 <- run_lmer_and_plot(good_bad_data_small, dv = "I_projection_valence_feel")
res2$model %>% table_model(dv_name = "I_projection_valence_feel")
```

------------------------------------------------------------------------

### I_projection_valence_feel individual variation

```{r}
res2$plot_line
```

------------------------------------------------------------------------

### I_projection_valence_feel spline fit

```{r}
res2$plot_spline
```

## I_projection_valence_combined

```{r}
res2 <- run_lmer_and_plot(good_bad_data_small, dv = "I_projection_valence_combined")
table_model(res2$model, dv_name = "I_projection_valence_combined")
```

------------------------------------------------------------------------

### I_projection_valence_combined individual variation

```{r}
res2$plot_line
```

------------------------------------------------------------------------

### I_projection_valence_combined spline fit

```{r}
res2$plot_spline
```

# First-person sing. valence projections (am, feel, & combined)

*Note.* Data are aggregated at the assessment level and coefficients are unstandardized.\n First person sing. = means of I, me, and my projections for each participant.

## first_person_sing_valence_feel

```{r}
res4 <- run_lmer_and_plot(good_bad_data_small, dv = "first_person_sing_valence_feel")
res4$model %>% table_model(dv_name = "first_person_sing_valence_feel")
```

------------------------------------------------------------------------

### first_person_sing_valence_feel individual variation

```{r}
res4$plot_line
```

------------------------------------------------------------------------

### first_person_sing_valence_feel spline fit

```{r}
res4$plot_spline
```

------------------------------------------------------------------------

## first_person_sing_valence_am

```{r}
res4 <- run_lmer_and_plot(good_bad_data_small, dv = "first_person_sing_valence_am")
res4$model %>% table_model(dv_name = "first_person_sing_valence_am")
```

------------------------------------------------------------------------

### first_person_sing_valence_am individual variation

```{r}
res4$plot_line
```

------------------------------------------------------------------------

### first_person_sing_valence_am spline fit

```{r}
res4$plot_spline

```

------------------------------------------------------------------------

## first_person_sing_valence_combined

```{r}
res3 <- run_lmer_and_plot(good_bad_data_small, dv = "first_person_sing_valence_combined")
res3$model %>% table_model(dv_name = "first_person_sing_valence_combined")
```

------------------------------------------------------------------------

### first_person_sing_valence_combined individual variation

```{r}
res3$plot_line
```

------------------------------------------------------------------------

### first_person_sing_valence_combined spline fit

```{r}
res3$plot_spline
```

# First-person sing. able projections (am, feel, & combined)

*Note.* Data are aggregated at the assessment level and coefficients are unstandardized.\n First person sing. = means of I, me, and my projections for each participant.

## first_person_sing_ability_am

```{r}
res5 <- run_lmer_and_plot(good_bad_data_small, dv = "first_person_sing_ability_am")
res5$model %>% table_model(dv_name = "first_person_sing_ability_am")
```

------------------------------------------------------------------------

### first_person_sing_ability_am individual variation

```{r}
res5$plot_line
```

------------------------------------------------------------------------

### first_person_sing_ability_am spline fit

```{r}
res5$plot_spline
```

## first_person_sing_ability_feel

```{r}
res6 <- run_lmer_and_plot(good_bad_data_small, dv = "first_person_sing_ability_feel")
res6$model %>% table_model(dv_name = "first_person_sing_ability_feel")
```

------------------------------------------------------------------------

### first_person_sing_ability_feel individual variation

```{r}
res6$plot_line
```

------------------------------------------------------------------------

### first_person_sing_ability_feel spline fit

```{r}
res6$plot_spline
```

## first_person_sing_ability_combined

```{r}
res4 <- run_lmer_and_plot(good_bad_data_small, dv = "first_person_sing_ability_combined")
res4$model %>% table_model(dv_name = "first_person_sing_ability_combined")
```

------------------------------------------------------------------------

### first_person_sing_ability_combined individual variation

```{r}
res4$plot_line
```

------------------------------------------------------------------------

### first_person_sing_ability_combined spline fit

```{r}
res4$plot_spline
```

# Relate the first-person singular projections to internalizing symptoms

Results are condensed to be for the first-person singular valence and ability projections only (combined).

```{r}
#| label: disaggregate and standardize
#### create disaggregated data 
between <- good_bad_data_small %>%
  gather(item, value,first_person_sing_valence_combined,first_person_sing_ability_combined,
         n_i,n_good,n_bad,pct_i,pct_good,pct_bad,n_total,tone_pos,tone_neg,emo_pos,emo_neg,pct_able,pct_unable
  ) %>%
  select(user_id, item, value) %>%
  unique() %>%
  group_by(user_id, item) %>%
  summarize(mean = mean(value, na.rm = TRUE)) %>%
  mutate(item = sprintf("%s_between", item)) %>%
  group_by(item) %>%
  mutate(mean = scale(mean, center = TRUE, scale = TRUE)) %>%
  spread(item, mean)

# Within-person variation
within <- good_bad_data_small %>%
  gather(item, value,first_person_sing_valence_combined,first_person_sing_ability_combined,
         n_i,n_good,n_bad,pct_i,pct_good,pct_bad,n_total,tone_pos,tone_neg,emo_pos,emo_neg,,pct_able,pct_unable) %>%
  group_by(user_id, item) %>%
  mutate(value = scale(value, center = TRUE, scale = TRUE),
         item = sprintf("%s_within", item)) %>%
  spread(item, value)

# Combine both within-person and between-person variation
disaggregated_good_bad <- within |> 
  left_join(between, by = "user_id") |> 
  select(1:14,daysSinceFirstText,Internalizing,first_person_sing_valence_combined_within,first_person_sing_valence_combined_between,
         first_person_sing_ability_combined_within, first_person_sing_ability_combined_between,n_i_within,
         n_i_between,n_good_within,n_good_between,n_bad_within,n_bad_between, pct_i_between,pct_i_within,pct_good_between,
         pct_good_within,pct_bad_between,pct_bad_within,n_total_within,n_total_between,tone_pos_within,tone_pos_between,tone_neg_within,
         tone_neg_between,emo_pos_within,emo_pos_between,emo_neg_within,emo_neg_between,pct_able_within,pct_able_between,pct_unable_within,pct_unable_between
  ) 



# Scale all the variables
good_bad_data_small <- good_bad_data_small|> 
  mutate(
    daysSinceFirstText = scale(daysSinceFirstText),
    Internalizing = scale(Internalizing),
    first_person_sing_valence_combined = scale(first_person_sing_valence_combined),
    first_person_sing_ability_combined = scale(first_person_sing_ability_combined),
    n_i = scale(n_i),
    n_good = scale(n_good),
    n_bad = scale(n_bad),
    pct_i = scale(pct_i),
    pct_good = scale(pct_good),
    pct_bad = scale(pct_bad),
    n_total = scale(n_total),
    tone_pos = scale(tone_pos),
    tone_neg = scale(tone_neg),
    emo_pos = scale(emo_pos),
    emo_neg = scale(emo_neg)
  )

disaggregated_good_bad$Internalizing <- scale(disaggregated_good_bad$Internalizing)
disaggregated_good_bad$daysSinceFirstText <- scale(disaggregated_good_bad$daysSinceFirstText)

```

## Valence Projection

:::: scrollable
::: panel-tabset
### Non-disaggregated

```{r}
internalizing <- lmer(Internalizing ~  first_person_sing_valence_combined + daysSinceFirstText + (1|room_id), data = good_bad_data_small)
table_model(internalizing, dv_name = "Good-Bad Internalizing model summary (Non-disagg)")
```

### Disaggregated

```{r}
dissagg_proj <- lmer(Internalizing ~ daysSinceFirstText + first_person_sing_valence_combined_within + first_person_sing_valence_combined_between + 
                       (1|room_id), data = disaggregated_good_bad) # need to optimize to get it to converge
table_model(dissagg_proj, dv_name = "Good-Bad Internalizing model summary (Disagg)")
```
:::
::::

## Ability Projection

:::: scrollable
::: panel-tabset
### Non-disaggregated

```{r}
internalizing_able <- lmer(Internalizing ~  first_person_sing_ability_combined + daysSinceFirstText + (1|room_id), data = good_bad_data_small)

table_model(internalizing_able, dv_name = "Able-Unable Internalizing model summary (Non-disagg)")
```

### Disaggregated

```{r}
internalizing_able_disagg <- lmer(Internalizing ~  first_person_sing_ability_combined_between + first_person_sing_ability_combined_within + daysSinceFirstText + (1|room_id), data = disaggregated_good_bad)
model_results_able_disagg <- extract_lmer_data(internalizing_able_disagg)
table_model(internalizing_able_disagg, dv_name = "Able-Unable Internalizing model summary (Disagg)")
```
:::
::::

# Controlling for other linguistic predictors of internalizing symptoms

Results are condensed to be for the first-person singular valence and ability projections only (combined).

## % words

Controlling for freq. of words used to construct our axes.

## Valence Projections

:::: scrollable
::: panel-tabset
### Non-disaggregated (Valence)

```{r}
pct_words <- lmer(Internalizing ~  pct_i + pct_good + pct_bad + n_total + first_person_sing_valence_combined + daysSinceFirstText +  (1|room_id), data = good_bad_data_small)
table_model(pct_words, dv_name = "% Good-bad Words model summary (Non-disagg)")
```

### Disaggregated (valence)

```{r}
pct_words_disagg <- lmer(Internalizing ~ daysSinceFirstText + first_person_sing_valence_combined_between +first_person_sing_valence_combined_within + pct_i_between + pct_i_within + pct_good_between + pct_good_within + pct_bad_between + pct_bad_within + n_total_within + n_total_between + (1|room_id), data = disaggregated_good_bad, control =
                           lmerControl(optimizer ="bobyqa")) # need to optimize to get it to converge
table_model(pct_words_disagg)
```
:::
::::

------------------------------------------------------------------------

## Ability Projections

:::: scrollable
::: panel-tabset
### Non-disaggregated (Ability)

```{r}
pct_words <- lmer(Internalizing ~  pct_i + pct_good + pct_bad + n_total + first_person_sing_ability_combined + daysSinceFirstText +  (1|room_id), data = good_bad_data_small)
table_model(pct_words, dv_name = "% Good-bad Words model summary (Non-disagg)")
```

### Disaggregated (ability)

```{r}
pct_words_disagg <- lmer(Internalizing ~ daysSinceFirstText + first_person_sing_ability_combined_between +first_person_sing_ability_combined_within + pct_i_between + pct_i_within + pct_able_between + pct_able_within + pct_unable_between + pct_unable_within + n_total_within + n_total_between + (1|room_id), data = disaggregated_good_bad, control =
                           lmerControl(optimizer ="bobyqa")) # need to optimize to get it to converge
table_model(pct_words_disagg, dv_name = "% Able-unable Words model summary (Disagg)")
```
:::
::::

------------------------------------------------------------------------

## Sentiment and Total WC

Controlling for sentiment scores, emotion words (LIWC), and total word count.

## Valence Projections

:::: scrollable
::: panel-tabset
### Non-disaggregated (valence)

```{r}
emo_wc <- lmer(Internalizing ~  first_person_sing_valence_combined + emo_pos + emo_neg + tone_pos + tone_neg + daysSinceFirstText + n_total + (1|room_id), data = good_bad_data_small)
table_model(emo_wc, dv_name = "Good-Bad Sentiment and Total WC model summary (Non-disagg)")
```

### Disaggregated (valence)

```{r}
#disagg
emo_wc_disagg <- lmer(Internalizing ~ daysSinceFirstText + first_person_sing_valence_combined_between + first_person_sing_valence_combined_within + emo_pos_within + emo_pos_between + emo_neg_within + emo_neg_between +
                        tone_pos_within + tone_pos_between + tone_neg_within + tone_neg_between + n_total_within + n_total_between + (1|room_id), data = disaggregated_good_bad, control =
                        lmerControl(optimizer ="bobyqa")) # need to optimize to get it to converge
emo_wc_disagg = extract_lmer_data(emo_wc_disagg)
cat("Good-bad Sentiment and Total WC model summary (Disagg):\n")
print(emo_wc_disagg) 
```
:::
::::

------------------------------------------------------------------------

## Ability projections

:::: scrollable
::: panel-tabset
### Non-disaggregated (ability)

```{r}
emo_wc <- lmer(Internalizing ~  first_person_sing_ability_combined + emo_pos + emo_neg + tone_pos + tone_neg + daysSinceFirstText + n_total + (1|room_id), data = good_bad_data_small)
table_model(emo_wc, dv_name = "Able-Unable Sentiment and Total WC model summary (Non-disagg)")
```

### Disaggregated (ability)

```{r}
emo_wc_disagg <- lmer(Internalizing ~ daysSinceFirstText + first_person_sing_ability_combined_between + first_person_sing_ability_combined_within + emo_pos_within + emo_pos_between + emo_neg_within + emo_neg_between +
                        tone_pos_within + tone_pos_between + tone_neg_within + tone_neg_between + n_total_within + n_total_between + (1|room_id), data = disaggregated_good_bad, control =
                        lmerControl(optimizer ="bobyqa")) # need to optimize to get it to converge
table_model(emo_wc_disagg, dv_name = "Able-Unable Sentiment and Total WC model summary (Disagg)")
```
:::
::::
