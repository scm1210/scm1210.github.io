---
title: "I-Projection Results"
author: "Steven"
date: "`r Sys.Date()`"
format: 
  revealjs:
    css: styles.css
    center: true  
    scrollable: true
    smaller: true
    controls: true
    progress: true
    keyboard: true
    slide-number: true 
    slideNumberFormat: "%current% / %total%"
    navigationMode: 'linear'
    transition: "slide"
    transitionSpeed: "fast"
    touch: true  
execute:
  fig-width: 5
  fig-height: 3
---

```{r load packages and installize conda environment, include=FALSE}
if (!require("pacman")) install.packages("pacman") #run this if you don't have pacman 
library(pacman)
pacman::p_load( DT, lmerTest, lme4, reactable,
  broom.mixed, knitr, kableExtra, ggrepel,
  ggeffects, patchwork, ggpubr, flexmix,
  effectsize, Rmisc,tidyverse,
  install = TRUE
)

good_palette <- c(
  "#772e25", "#c44536", "#ee9b00", "#197278", "#283d3b", 
  "#9CC5A1", "#6195C6", "#ADA7C9", "#4D4861", "grey50",
  "#d4a373", "#8a5a44", "#4a6a74", "#5c80a8", "#a9c5a0",
  "#7b9b8e", "#e1b16a", "#a69b7c", "#9d94c4", "#665c54")

able_palette <- c(
  "#ED553B",  # reddish-orange
  "#3CAEA3",  # teal
  "#20639B",  # deep blue
  "#173F5F",  # navy
  "#FFD166",  # soft yellow
  "#6A4C93",  # purple
  "#FF6F61",  # coral
  "#88B04B",  # olive green
  "#92A8D1"   # dusty blue
)

palette_condition = c("#ee9b00", "#c44536","#005f73", "#283d3b", "#9CC5A1", "#6195C6", "#ADA7C9", "#4D4861")
plot_aes = theme_minimal() +
  theme(legend.position = "bottom",
        legend.text = element_text(size = 12),
        text = element_text(size = 12, family = "Futura Medium"),
        axis.text = element_text(color = "black"),
        axis.ticks.y = element_blank())

```

```{r helper functions}
table_model <- function(model, reference = "Intercept", dv_name = "dependent_variable") {
  # Extract the tidy data from the model directly
  model_data <- tidy(model, conf.int = TRUE)
  
  # Process the model data
  model_table <- model_data %>%
    filter(effect == "fixed") %>%
   dplyr::rename("SE" = std.error,
           "t" = statistic,
           "p" = p.value) %>%
   dplyr::select(-group, -effect) %>%
    dplyr::mutate(across(where(is.numeric), ~round(., 3))) %>%
    dplyr::mutate(
      term = gsub("\\(Intercept\\)", !!reference, term),
      term = gsub(":", " x ", term),
      term = gsub("ethnicity", "", term),
      p_original = p,
      p = ifelse(p < .001, "< .001",
                 ifelse(p == 1, "1.000", gsub("0.(.*)", ".\\1", sprintf("%.3f", p)))),
      `b [95% CI]` = sprintf("%.4f [%0.4f, %.4f]", estimate, conf.low, conf.high),  # Changed estimate to 4 decimal places
      significance = case_when(
        p_original < 0.001 ~ "***",
        p_original < 0.01 ~ "**",
        p_original < 0.05 ~ "*",
        p_original < 0.10 ~ "+",
        TRUE ~ ""
      )
    ) %>%
    dplyr::select(term, `b [95% CI]`, df, SE, t, p, significance)
  
  # Create a datatable for displaying results
dt_table <- datatable(model_table)

  return(dt_table)
}


extract_lmer_data <- function(model) {
  # Ensure the broom.mixed package is available
  if (!requireNamespace("broom.mixed", quietly = TRUE)) {
    stop("Please install the 'broom.mixed' package to use this function.")
  }
  
  # Extract fixed effects with 95% confidence intervals
  fixed_effects <- broom.mixed::tidy(model, effects = "fixed", conf.int = TRUE)
  
  # Add the 'outcome' column with the value "Internalizing"
  fixed_effects <- fixed_effects %>%
    dplyr::mutate(outcome = "Internalizing")
  
  return(fixed_effects)
}

palette_counter <- 1  # start index

run_lmer_and_plot <- function(data, dv, iv = "daysSinceFirstText", group_var = "room_id",
                              title = "Change in Projection Over Time", ylab = "Projection") {
  # Use color from palette and increment counter
  color <- good_palette[palette_counter]
  palette_counter <<- ifelse(palette_counter < length(good_palette), 
                             palette_counter + 1, 1)  # cycle back to start
  
  formula <- as.formula(paste(dv, "~", iv, "+ (1|", group_var, ")"))
  
  model <- lmer(formula, data = data)
  
  # Predictions
  pred <- ggpredict(model, terms = iv)
  
  # Line + ribbon plot
  plot1 <- ggplot() +
  geom_line(data = data,
              aes_string(x = iv, y = dv, group = group_var),
              color = color, alpha = 0.01) +
 geom_line(data = pred, aes(x = x, y = predicted),
            color = color, size = 1.05, inherit.aes = FALSE) +
    geom_ribbon(data = pred,
                aes(x = x, ymin = conf.low, ymax = conf.high),
                fill = color, alpha = 0.2) +
    labs(
      title = title,
      x = iv,
      y = ylab
    ) + plot_aes
  
  # Spline-only plot
  plot2 <- ggplot(data, aes_string(x = iv, y = dv)) +
    geom_smooth(method = "gam", formula = y ~ s(x, k = 5),
                color = color, fill = color, alpha = 0.2) +
    labs(
      title = paste(title, "\n(Spline Fit)"),
      x = iv,
      y = ylab
    ) + plot_aes
  
  return(list(model = model, pred = pred, plot_line = plot1, plot_spline = plot2, color = color))
}

data_dir = "/Users/sm9518/Library/CloudStorage/Box-Box/Talkspace_ErikNook_HarvardPrinceton/Data/Processed/Mesquiti_LBA_2024/Talkspace-LBA"

```

```{r}
#data = read_csv(file.path(data_dir, "I-representations/data/text-level/MADS_roberta_results_Indy_am_v_feel_cleaned.csv")) # use for the am/feel data 
#data = read_csv(file.path(data_dir, "I-representations/data/text-level/MADS_roberta_results_origin_full.csv")) # has the original 3 pronounds
data = read_csv(file.path(data_dir, "I-representations/data/text-level/MADS_roberta_results_origin_full_pronouns.csv"))

  data = data %>%
    dplyr::rename(
      Internalizing = internalizing,
      daysSinceFirstText = days_since_first_text
    ) %>% 
    filter(bin < 5)  %>% 
   dplyr:: mutate(
      first_person_sing_valence_combined = rowMeans(select(., i_projection_valence, me_projection_valence, my_projection_valence,myself_projection_valence,mine_projection_valence), na.rm = TRUE),
      first_person_sing_ability_combined = rowMeans(select(., i_projection_ability, me_projection_ability, my_projection_ability,myself_projection_ability,mine_projection_ability), na.rm = TRUE)
      )


good_bad_data_small =  data |> 
  dplyr::group_by(room_id,daysSinceFirstText) %>%
  dplyr::summarise(across(
    where(is.numeric),
    mean,
    na.rm = TRUE
  ), .groups = "drop") |> 
  dplyr::filter(n_total > 20)

#length(unique(data$room_id))

```

# Q1.) Do projections move closer to the positive end of the axis over time?

*Note.* Data are aggregated at the assessment level and coefficients are unstandardized.\n First person sing. = means of I, me, and my projections for each participant.

## First-person sing. valence projections

```{r}
res3 <- run_lmer_and_plot(good_bad_data_small, dv = "first_person_sing_valence_combined")
res3$model %>% table_model(dv_name = "first_person_sing_valence_combined")
```

------------------------------------------------------------------------

### first_person_sing_valence_combined individual variation

```{r}
res3$plot_line
```

------------------------------------------------------------------------

### first_person_sing_valence_combined spline fit

```{r}
res3$plot_spline
```

# First-person sing. able projections 

*Note.* Data are aggregated at the assessment level and coefficients are unstandardized.\n First person sing. = means of I, me, and my projections for each participant.

## first_person_sing_ability_combined

```{r}
res4 <- run_lmer_and_plot(good_bad_data_small, dv = "first_person_sing_ability_combined")
res4$model %>% table_model(dv_name = "first_person_sing_ability_combined")
```

------------------------------------------------------------------------

### first_person_sing_ability_combined individual variation

```{r}
res4$plot_line
```

------------------------------------------------------------------------

### first_person_sing_ability_combined spline fit

```{r}
res4$plot_spline
```


```{r}
#| label: disaggregate and standardize
#### create disaggregated data 
between <- good_bad_data_small %>%
  tidyr::gather(item, value,first_person_sing_valence_combined,first_person_sing_ability_combined,
         n_i,n_good,n_bad,pct_i,pct_good,pct_bad,n_total,tone_pos,tone_neg,emo_pos,emo_neg,pct_able,pct_unable,i
  ) %>%
  select(user_id, item, value) %>%
  unique() %>%
  group_by(user_id, item) %>%
  summarize(mean = mean(value, na.rm = TRUE)) %>%
  mutate(item = sprintf("%s_between", item)) %>%
  group_by(item) %>%
  mutate(mean = scale(mean, center = TRUE, scale = TRUE)) %>%
  spread(item, mean)

# Within-person variation
within <- good_bad_data_small %>%
  gather(item, value,first_person_sing_valence_combined,first_person_sing_ability_combined,
         n_i,n_good,n_bad,pct_i,pct_good,pct_bad,n_total,tone_pos,tone_neg,emo_pos,emo_neg,,pct_able,pct_unable,i) %>%
  group_by(user_id, item) %>%
  mutate(value = scale(value, center = TRUE, scale = TRUE),
         item = sprintf("%s_within", item)) %>%
  spread(item, value)

# Combine both within-person and between-person variation
disaggregated_good_bad <- within |> 
  left_join(between, by = "user_id") |> 
  select(1:14,daysSinceFirstText,Internalizing,first_person_sing_valence_combined_within,first_person_sing_valence_combined_between,
         first_person_sing_ability_combined_within, first_person_sing_ability_combined_between,n_i_within,
         n_i_between,n_good_within,n_good_between,n_bad_within,n_bad_between, pct_i_between,pct_i_within,pct_good_between,
         pct_good_within,pct_bad_between,pct_bad_within,n_total_within,n_total_between,tone_pos_within,tone_pos_between,tone_neg_within,
         tone_neg_between,emo_pos_within,emo_pos_between,emo_neg_within,emo_neg_between,pct_able_within,pct_able_between,pct_unable_within,pct_unable_between,i_between,i_within
  ) 



# Scale all the variables
good_bad_data_small <- good_bad_data_small|> 
  mutate(
    daysSinceFirstText = scale(daysSinceFirstText),
    Internalizing = scale(Internalizing),
    first_person_sing_valence_combined = scale(first_person_sing_valence_combined),
    first_person_sing_ability_combined = scale(first_person_sing_ability_combined),
    n_i = scale(n_i),
    n_good = scale(n_good),
    n_bad = scale(n_bad),
    pct_i = scale(pct_i),
    pct_good = scale(pct_good),
    pct_bad = scale(pct_bad),
    pct_able = scale(pct_able),
    pct_unable = scale(pct_unable),
    n_total = scale(n_total),
    tone_pos = scale(tone_pos),
    tone_neg = scale(tone_neg),
    emo_pos = scale(emo_pos),
    emo_neg = scale(emo_neg),
    i = scale(i)
  )

disaggregated_good_bad$Internalizing <- scale(disaggregated_good_bad$Internalizing)
disaggregated_good_bad$daysSinceFirstText <- scale(disaggregated_good_bad$daysSinceFirstText)

```

# Scaled Change over time (standardized coefficients)

## Good

```{r}
library(parameters)
library(effectsize)
good_change <- lmer(first_person_sing_valence_combined ~   daysSinceFirstText + (1|room_id), data = good_bad_data_small)
standardize_parameters(good_change, method = "pseudo", ci_method = "satterthwaite") |> 
  as_tibble() |> 
    rename(
      term = Parameter,
      Std_Coefficient = Std_Coefficient,
      CI_low = CI_low,
      CI_high = CI_high
    ) %>%
    select(term, Std_Coefficient, CI_low, CI_high) |> 
    dplyr::mutate(across(where(is.numeric), ~round(., 3))) |> 
    as.data.frame() |> 
    DT::datatable()
```

## Able

```{r}
able_change <- lmer(first_person_sing_ability_combined ~   daysSinceFirstText + (1|room_id), data = good_bad_data_small)
standardize_parameters(able_change, method = "pseudo", ci_method = "satterthwaite") |> 
  as_tibble() |> 
    rename(
      term = Parameter,
      Std_Coefficient = Std_Coefficient,
      CI_low = CI_low,
      CI_high = CI_high
    ) %>%
    select(term, Std_Coefficient, CI_low, CI_high) |> 
    dplyr::mutate(across(where(is.numeric), ~round(., 3))) |> 
    as.data.frame() |> 
    DT::datatable()
```

# Q2.) Do our projection measures predict changes in internalizing symptoms over time?

Results are condensed to be for the first-person singular valence and ability projections only (combined).


## Valence Projection

:::: scrollable
::: panel-tabset
### Non-disaggregated

```{r}
internalizing <- lmer(Internalizing ~  first_person_sing_valence_combined + daysSinceFirstText + (1|room_id), data = good_bad_data_small)
table_model(internalizing, dv_name = "Good-Bad Internalizing model summary (Non-disagg)")
```

### Disaggregated

```{r}
dissagg_proj <- lmer(Internalizing ~ daysSinceFirstText + first_person_sing_valence_combined_within + first_person_sing_valence_combined_between + 
                       (1|room_id), data = disaggregated_good_bad) # need to optimize to get it to converge
table_model(dissagg_proj, dv_name = "Good-Bad Internalizing model summary (Disagg)")
```
:::
::::

## Ability Projection

:::: scrollable
::: panel-tabset
### Non-disaggregated

```{r}
internalizing_able <- lmer(Internalizing ~  first_person_sing_ability_combined + daysSinceFirstText + (1|room_id), data = good_bad_data_small)

table_model(internalizing_able, dv_name = "Able-Unable Internalizing model summary (Non-disagg)")
```

### Disaggregated

```{r}
internalizing_able_disagg <- lmer(Internalizing ~  first_person_sing_ability_combined_between + first_person_sing_ability_combined_within + daysSinceFirstText + (1|room_id), data = disaggregated_good_bad)
model_results_able_disagg <- extract_lmer_data(internalizing_able_disagg)
table_model(internalizing_able_disagg, dv_name = "Able-Unable Internalizing model summary (Disagg)")
```
:::
::::

# Q3.) Are these predictions robust to other linguisitic features?

Results are condensed to be for the first-person singular valence and ability projections only (combined).


## Valence Projections

:::: scrollable
::: panel-tabset
### Non-disaggregated (Valence)

```{r}
pct_words <- lmer(Internalizing ~  i + pct_good + pct_bad + n_total  + tone_pos + tone_neg + daysSinceFirstText +  first_person_sing_valence_combined + daysSinceFirstText +  (1|room_id), data = good_bad_data_small)
table_model(pct_words, dv_name = "Good-bad Words Controls (Non-disagg)")
```


### Disaggregated (valence)


```{r}
pct_words_disagg <- lmer(Internalizing ~ daysSinceFirstText + first_person_sing_valence_combined_between + first_person_sing_valence_combined_within + 
                        tone_pos_within + tone_pos_between + tone_neg_within + tone_neg_between + n_total_within + n_total_between + i_between + i_within + pct_good_between + pct_good_within + pct_bad_between + pct_bad_within +  (1|room_id), data = disaggregated_good_bad) # need to optimize to get it to converge
table_model(pct_words_disagg)
```
:::
::::

------------------------------------------------------------------------

## Ability Projections

:::: scrollable
::: panel-tabset
### Non-disaggregated (Ability)


```{r}
pct_words <- lmer(Internalizing ~ i + pct_able + pct_unable+ n_total + tone_pos + tone_neg + daysSinceFirstText + first_person_sing_ability_combined + daysSinceFirstText +  (1|room_id), data = good_bad_data_small)
table_model(pct_words, dv_name = "% Good-bad Words model summary (Non-disagg)")
```

### Disaggregated (ability)

**Note:** The ability models include percentage variables for "able" and "unable" language. The `pct_unable` variable has substantial missing data (~74% of observations) as "unable" language is relatively rare. As a result, these models are estimated on a subset of participants who exhibit variation in ability-related language. 

```{r}
pct_words_disagg <- lmer(Internalizing ~ daysSinceFirstText + first_person_sing_ability_combined_between +first_person_sing_ability_combined_within + 
                        tone_pos_within + tone_pos_between + tone_neg_within + tone_neg_between + n_total_within + n_total_between + i_between + i_within + pct_able_between + pct_able_within + pct_unable_between + pct_unable_within + (1|room_id), data = disaggregated_good_bad) # need to optimize to get it to converge
table_model(pct_words_disagg, dv_name = "% Able-unable Words model summary (Disagg)")
```
:::
::::

# Q4) Is this occurring for all words, or is “I” unique in some way?

```{r}
# remake the small dataframe 

good_bad_data_small =  data |> 
  dplyr::group_by(room_id,daysSinceFirstText) %>%
  dplyr::summarise(across(
    where(is.numeric),
    mean,
    na.rm = TRUE
  ), .groups = "drop") |> 
  dplyr::filter(n_total > 20)

# and now select only the columns we need


#disaggregate data

between <- good_bad_data_small %>%
  gather(item, value,
         first_person_sing_valence_combined, first_person_sing_ability_combined,
         we_projection_ability,we_projection_valence,
         a_projection_valence, a_projection_ability,
         an_projection_valence, an_projection_ability,
         the_projection_valence, the_projection_ability) %>%
  select(user_id, item, value) %>%
  unique() %>%
  group_by(user_id, item) %>%
  summarize(mean = mean(value, na.rm = TRUE), .groups = "drop") %>%
  mutate(item = sprintf("%s_between", item)) %>%
  group_by(item) %>%
  mutate(mean = scale(mean, center = TRUE, scale = TRUE)) %>%
  spread(item, mean)

# Within-person variation
within <- good_bad_data_small %>%
  gather(item, value,
         first_person_sing_valence_combined, first_person_sing_ability_combined,
         we_projection_ability,
         we_projection_valence,
         a_projection_valence, a_projection_ability,
         an_projection_valence, an_projection_ability,
         the_projection_valence, the_projection_ability) %>%
  group_by(user_id, item) %>%
  mutate(value = scale(value, center = TRUE, scale = TRUE),
         item = sprintf("%s_within", item)) %>%
  spread(item, value)

# Combine both within-person and between-person variation
disaggregated <- within %>%
  left_join(between, by = "user_id") 

good_bad_data_small = good_bad_data_small |> 
  mutate(
    daysSinceFirstText = scale(daysSinceFirstText),
    Internalizing = scale(Internalizing),
    first_person_sing_valence_combined = scale(first_person_sing_valence_combined),
    first_person_sing_ability_combined = scale(first_person_sing_ability_combined),
    we_projection_valence = scale(we_projection_valence),
    we_projection_ability = scale(we_projection_ability),
    a_projection_valence = scale(a_projection_valence),
    a_projection_ability = scale(a_projection_ability),
    an_projection_valence = scale(an_projection_valence),
    an_projection_ability = scale(an_projection_ability),
    the_projection_valence = scale(the_projection_valence),
    the_projection_ability = scale(the_projection_ability)
  )


```

## Changes in Meaning over Time

::: scrollable
```{r}
#| fig-height: 10
#| fig-width: 8
dv_list <- c(
"first_person_sing_valence_combined",
"first_person_sing_ability_combined",
"a_projection_valence",
"a_projection_ability",
"we_projection_valence",
"we_projection_ability",
"an_projection_valence",
"an_projection_ability",
"the_projection_valence",
"the_projection_ability"
)


# Extract fixed effects for each DV
mads_coefs <- map_dfr(dv_list, function(dv) {
  model <- lmer(as.formula(paste0(dv, " ~ daysSinceFirstText + (1|room_id)")), data = good_bad_data_small)
  broom.mixed::tidy(model, effects = "fixed", conf.int = TRUE) |>
    filter(term == "daysSinceFirstText") |>
    mutate(term = "Days in Therapy", outcome = dv)
})


max_y <- length(unique(mads_coefs$outcome)) + 0.5

mads_coefs |> 
ggplot(aes(x = estimate, y = factor(outcome),
                       xmin = conf.low, xmax = conf.high, color = outcome)) +
  geom_pointrange(position = position_dodge(width = 0.6), size = 1.1, linewidth = 1.5) +
  geom_text(aes(label = case_when(
    p.value < 0.001 ~ "***",
    p.value < 0.01 ~ "**",
    p.value < 0.05 ~ "*",
    TRUE ~ ""
  )),
  position = position_dodge(width = 0.7),
  hjust = 0.5,
  vjust = 0.01,
  size = 6,
  color = "black") +
  scale_color_manual(values = good_palette) +
  scale_alpha_manual(values = c(0.1, 1), guide = FALSE) +
  labs(
    title = "Do words move over time?",
    x = "Coefficient Estimate",
    y = NULL,
    color = "Word"
  ) +
  geom_vline(xintercept = 0, linetype = "dashed") +
  annotate("text", x = -0.20, y = max_y, label = "← Bad/Unable", hjust = 0, size = 3, fontface = "italic") +
  annotate("text", x =  0.18, y = max_y, label = "Good/Able →", hjust = 1, size = 3, fontface = "italic") +
  theme_minimal() +
  theme(
    legend.position = "none",
    legend.text = element_text(size = 12),
    text = element_text(size = 16, family = "Futura Medium"),
    axis.text = element_text(color = "black"),
    axis.ticks.y = element_blank(),
    plot.title = element_text(hjust = 0.5, face = "bold"),
    plot.subtitle = element_text(hjust = 0.5)
  )

```
:::

## Track with Changes in Symptoms

:::: scrollable
::: panel-tabset
### Non-disaggregated

```{r}
#| fig-height: 8
#| fig-width: 10
dv_list <- c(
"first_person_sing_valence_combined",
"first_person_sing_ability_combined",
"we_projection_valence",
"we_projection_ability",
"a_projection_valence",
"a_projection_ability",
"an_projection_valence",
"an_projection_ability",
"the_projection_valence",
"the_projection_ability"
)
mads_coefs <- map_dfr(dv_list, function(dv) {
  formula_str <- paste0("Internalizing ~ daysSinceFirstText + ", dv, " + (1|room_id)")
  model <- lmer(as.formula(formula_str), data = good_bad_data_small)
  
  broom.mixed::tidy(model, effects = "fixed", conf.int = TRUE) |>
    filter(term == dv)
})



max_y <- length(unique(mads_coefs$estimate)) + 0.5

mads_coefs |> 
ggplot(aes(x = estimate, y = factor(term),
                       xmin = conf.low, xmax = conf.high, color = term)) +
  geom_pointrange(position = position_dodge(width = 0.6), size = 1.1, linewidth = 1.5) +
  geom_text(aes(label = case_when(
    p.value < 0.001 ~ "***",
    p.value < 0.01 ~ "**",
    p.value < 0.05 ~ "*",
    TRUE ~ ""
  )),
  position = position_dodge(width = 0.7),
  hjust = 0.5,
  vjust = 0.01,
  size = 6,
  color = "black") +
  scale_color_manual(values = good_palette) +
  scale_alpha_manual(values = c(0.1, 1), guide = FALSE) +
  labs(
    title = "Do words closer to good/able track with reduced sx",
    x = "Coefficient Estimate",
    y = NULL,
    color = "Word"
  ) +
  geom_vline(xintercept = 0, linetype = "dashed") +
  annotate("text", x = -0.2, y = max_y, label = "← Fewer Sx", hjust = 0, size = 3, fontface = "italic") +
  annotate("text", x =  0.18, y = max_y, label = "More Sx →", hjust = 1, size = 3, fontface = "italic") +
  theme_minimal() +
  theme(
    legend.position = "none",
    legend.text = element_text(size = 12),
    text = element_text(size = 16, family = "Futura Medium"),
    axis.text = element_text(color = "black"),
    axis.ticks.y = element_blank(),
    plot.title = element_text(hjust = 0.5, face = "bold"),
    plot.subtitle = element_text(hjust = 0.5)
  )
```
### Disaggregated

```{r}
#| fig-height: 10
#| fig-width: 8

dv_list <- c(
"first_person_sing_valence_combined",
"first_person_sing_ability_combined",
"we_projection_valence",
"we_projection_ability",
"a_projection_valence",
"a_projection_ability",
"an_projection_valence",
"an_projection_ability",
"the_projection_valence",
"the_projection_ability"
)

mads_coefs <- purrr::map_dfr(dv_list, function(dv_base) {
  dv_between <- paste0(dv_base, "_between")
  dv_within  <- paste0(dv_base, "_within")
  
  formula_str <- paste0("Internalizing ~ daysSinceFirstText + ", 
                        dv_between, " + ", dv_within, " + (1|room_id)")
  
  model <- lmerTest::lmer(as.formula(formula_str), data = disaggregated)
  
  broom.mixed::tidy(model, effects = "fixed", conf.int = TRUE, p.values = TRUE) |>
    filter(term %in% c(dv_between, dv_within)) |>
    mutate(
      term = case_when(
        term == dv_between ~ "Between",
        term == dv_within ~ "Within"
      ),
      model = dv_base
    )
})

max_y <- length(unique(mads_coefs$estimate)) + 0.5

mads_coefs |> 
  ggplot(aes(x = estimate, y = term,
             xmin = conf.low, xmax = conf.high, color = term)) +
  geom_pointrange(size = 1.1, linewidth = 1.5) +
  geom_text(aes(label = case_when(
      p.value < 0.001 ~ "***",
      p.value < 0.01 ~ "**",
      p.value < 0.05 ~ "*",
      TRUE ~ ""
    )),
    hjust = 0.5,
    vjust = -0.7,
    size = 5,
    color = "black"
  ) +
  scale_color_manual(values = good_palette) +
  labs(
    title = "Do words closer to good/able track with reduced sx",
    x = "Coefficient Estimate",
    y = NULL,
    color = NULL
  ) +
  geom_vline(xintercept = 0, linetype = "dashed") +
  facet_wrap(~ model, ncol = 2, scales = "fixed") +
  theme_minimal() +
  theme(
    legend.position = "none",
    text = element_text(size = 16, family = "Futura Medium"),
    axis.text = element_text(color = "black"),
    axis.title.x = element_text(margin = margin(t = 10)),
    axis.text.y = element_text(size = 12),
    strip.text = element_text(face = "bold", size = 14),
    axis.ticks.y = element_blank(),
    plot.title = element_text(hjust = 0.5, face = "bold")
  )

```
:::
::::



```{r}
dv_list <- c(
"first_person_sing_valence_combined",
"first_person_sing_ability_combined"
)



mads_coefs <- map_dfr(dv_list, function(dv_base) {
  dv_between <- paste0(dv_base, "_between")
  dv_within  <- paste0(dv_base, "_within")
  
  formula_str <- paste0("Internalizing ~ daysSinceFirstText + ", 
                        dv_between, " + ", dv_within, " + (1|room_id)")
  
  # Fit the model
  model <- lmerTest::lmer(as.formula(formula_str), data = disaggregated)
  
  # Tidy original estimates
  tidy_df <- broom.mixed::tidy(model, effects = "fixed", conf.int = TRUE, p.values = TRUE) %>%
    filter(term %in% c(dv_between, dv_within))
  
  # Standardized coefficients
  stan_df <- standardize_parameters(model, method = "pseudo", ci_method = "satterthwaite") %>%
    as_tibble() %>%
    rename(
      term = Parameter,
      Std_Coefficient = Std_Coefficient,
      CI_low = CI_low,
      CI_high = CI_high
    ) %>%
    select(term, Std_Coefficient, CI_low, CI_high)
  
  # Merge standardized coefficients into tidy_df and keep model column
  tidy_df <- tidy_df %>%
    left_join(stan_df, by = "term") %>%
    mutate(
      term = case_when(
        term == dv_between ~ "Between",
        term == dv_within ~ "Within"
      ),
      model = dv_base  # preserve model name
    )
  
  tidy_df
})

disagg_plot <- mads_coefs %>%
  mutate(
    model = case_when(
      model == "first_person_sing_valence_combined" ~ "I/me/my = good",
      model == "first_person_sing_ability_combined" ~ "I/me/my = able",
      TRUE ~ model
    ),
    term = case_when(
     term == "Within" ~ "Within-Person\nEffect",
      term == "Between" ~ "Between-Person\nEffect",
      TRUE ~ term
    ),
    term = factor(term, levels = c("Between-Person\nEffect", "Within-Person\nEffect")),
    effect_combo = paste(model, term, sep = "_")
  ) %>%
  ggplot(aes(
    x = Std_Coefficient, 
    y = term,
    xmin = CI_low, 
    xmax = CI_high,
    color = term  # <-- map color here
  )) +
  geom_pointrange(size = 1.25, linewidth = 1.5, position = position_dodge(width = 0.5)) +
  geom_text(aes(label = case_when(
      p.value < 0.001 ~ "***",
      p.value < 0.01 ~ "**",
      p.value < 0.05 ~ "*",
      TRUE ~ ""
    )),
    hjust = 0.5, vjust = -0.7, size = 5, color = "black",
    position = position_dodge(width = 0.5)
  ) +
  scale_color_manual(values = good_palette) +
  labs(
    x = "Standardized Coefficients",
    y = NULL,
    color = "Effect Type"
  ) +
  scale_y_discrete(limits = rev) + 
  facet_wrap(~ model, ncol = 2, scales = "fixed") +
  geom_vline(xintercept = 0, linetype = "dashed") +
  theme_minimal() +
  theme(
    legend.position = "none",
    text = element_text(size = 24, family = "Futura Medium"),
    axis.text = element_text(color = "black"),
    axis.title.x = element_text(margin = margin(t = 10)),
    axis.text.y = element_text(size = 18),
    strip.text = element_text(face = "bold", size = 24),
    axis.ticks.y = element_blank(),
    plot.title = element_text(hjust = 0.5, face = "bold", size = 28),
     panel.spacing = unit(3, "lines")  # <-- adds extra space between facets
  )

disagg_plot

ggsave("/Users/sm9518/Downloads/disagg_plot.png", disagg_plot, width = 8.5, height = 5, dpi = 300)

```


```{r}

data = read_csv(file.path(data_dir, "I-representations/data/text-level/MADS_roberta_results_Indy_am_v_feel_cleaned.csv"))
data = data %>%
  dplyr::rename(
    Internalizing = internalizing,
    daysSinceFirstText = days_since_first_text
  ) %>% 
  filter(bin < 5)  %>% 
 dplyr:: mutate(
    first_person_sing_valence_am = rowMeans(select(., I_projection_valence_am, me_projection_valence_am, my_projection_valence_am), na.rm = TRUE),
    first_person_sing_valence_feel = rowMeans(select(., I_projection_valence_feel, me_projection_valence_feel, my_projection_valence_feel), na.rm = TRUE),
    first_person_sing_valence_combined = rowMeans(select(., I_projection_valence_combined, me_projection_valence_combined, my_projection_valence_combined), na.rm = TRUE),
    first_person_sing_ability_am = rowMeans(select(., I_projection_ability_am, me_projection_ability_am, my_projection_ability_am), na.rm = TRUE),
    first_person_sing_ability_feel = rowMeans(select(., I_projection_ability_feel, me_projection_ability_feel, my_projection_ability_feel), na.rm = TRUE),
    first_person_sing_ability_combined = rowMeans(select(., I_projection_ability_combined, me_projection_ability_combined, my_projection_ability_combined), na.rm = TRUE)
    )
good_bad_data_small =  data |> 
  dplyr::group_by(room_id,daysSinceFirstText) %>%
  dplyr::summarise(across(
    where(is.numeric),
    mean,
    na.rm = TRUE
  ), .groups = "drop") |> 
  dplyr::filter(n_total > 20)

good_bad_data_small_scaled = good_bad_data_small |> 
  mutate(
    daysSinceFirstText = scale(daysSinceFirstText),
    Internalizing = scale(Internalizing),
    first_person_sing_valence_combined = scale(first_person_sing_valence_combined),
    first_person_sing_ability_combined = scale(first_person_sing_ability_combined)
  )

data_plot = good_bad_data_small |> 
  select(room_id, user_id,daysSinceFirstText, Internalizing, first_person_sing_valence_combined, first_person_sing_ability_combined) |> 
  pivot_longer(cols = c(first_person_sing_valence_combined, first_person_sing_ability_combined), 
               names_to = "projections", values_to = "distance") |> 
  mutate(projections = ifelse(projections == "first_person_sing_valence_combined", 
                              "I/me/my = good",  "I/me/my = able"))

```

```{r}
#| eval: false
#| include: false
projections <- c("first_person_sing_valence_combined", "first_person_sing_ability_combined")

annotation_df <- lapply(projections, function(proj) {
  # Fit model on scaled data
  model <- lmer(as.formula(paste0(proj, " ~ daysSinceFirstText + (1|room_id)")),
                data = good_bad_data_small_scaled)
  
  # Get standardized parameters
  model_stan <- standardize_parameters(model, method = "pseudo", ci_method = "satterthwaite")
  model_stan_df <- as_tibble(model_stan) %>%
    rename(
      term = Parameter,
      Std_Coefficient = Std_Coefficient,
      CI_low = CI_low,
      CI_high = CI_high
    ) %>%
    select(term, Std_Coefficient, CI_low, CI_high)
  
  # Extract standardized coefficient for daysSinceFirstText
  std_coeff <- model_stan_df %>% filter(term == "daysSinceFirstText") %>% pull(Std_Coefficient)
  
  # Extract p-value from the unstandardized model (for significance stars)
  p_val <- summary(model)$coefficients["daysSinceFirstText", "Pr(>|t|)"]
  
  # Reference x for annotation
  ref_x <- mean(good_bad_data_small$daysSinceFirstText, na.rm = TRUE)
  
  # Predict fitted value at reference x (unstandardized scale)
  fitted_y <- predict(model, newdata = data.frame(daysSinceFirstText = ref_x, room_id = NA), re.form = NA)
  
  # Significance label
  sig_label <- case_when(
    p_val < 0.001 ~ "***",
    p_val < 0.01  ~ "**",
    p_val < 0.05  ~ "*",
    TRUE ~ "n.s."
  )
  
  # Small offset above line
  offset <- 0.005 * diff(range(good_bad_data_small_scaled[[proj]], na.rm = TRUE))
  
  # Combine standardized coefficient and significance
  label_text <- paste0("β = ", round(std_coeff, 3), " ", sig_label)
  
  data.frame(
    projections = ifelse(proj == "first_person_sing_valence_combined", 
                         "I/me/my = good", "I/me/my = able"),
    x = ref_x,
    y = fitted_y + offset,
    label = label_text
  )
}) |> bind_rows()

# Plot with annotations
plot <- data_plot |> 
  ggplot(aes(x = daysSinceFirstText, y = distance, group = user_id, color = projections)) +
  geom_smooth(
    aes(group = projections, fill = projections),
    method = "lm",
    se = TRUE,
    size = 1.5,
    alpha = 0.25   # makes the confidence ribbon semi-transparent
  ) +
  scale_color_manual(values = good_palette, name = "") +
  scale_fill_manual(values = good_palette, name = "") +  # ensures ribbon matches line color
  labs(y = "Projections Score", x = "Days in Therapy") +
  plot_aes +
  facet_wrap(~projections, scales = "free_y") +
  geom_text(
    data = annotation_df,
    aes(x = 45, y = 0.3, label = label),
    inherit.aes = FALSE,
    hjust = 0.5,
    vjust = -0.5,
    size = 12
  ) +
  theme_minimal() +
  theme(
    legend.position = "none",
    plot.title = element_text(hjust = 0.5, size = 24, face = "bold"),
    plot.subtitle = element_text(hjust = 0.5, face = "bold"),
    text = element_text(size = 24, family = "Futura Medium"),
    plot.caption = element_text(hjust = 0, size = 20, face = "italic")
  )
plot

ggsave("/Users/sm9518/Downloads/line_plot.png", plot, width = 18, height = 6, dpi = 300)


#ggsave("/Users/sm9518/Downloads/line_plot_points.png", plot, width = 10, height = 7.5, dpi = 300)

```


