<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.40">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Steven Mesquiti">

<title>LLM to HPC Tutorial</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-dark-8ea72dc5fed832574809a9c94082fbbb.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap-0063d04294f35071145263a56bfbe081.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="dark">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../about.html"> 
<span class="menu-text">Steven Mesquiti</span></a>
  </li>  
</ul>
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../about.html"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../publications.html"> 
<span class="menu-text">Publications &amp; Preprints</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../CV.html"> 
<span class="menu-text">CV</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../posts.html"> 
<span class="menu-text">Posts</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../coding.html"> 
<span class="menu-text">Coding Guide</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#how-to-download-and-set-up-meta-llama-3-models-on-hpc-adroit" id="toc-how-to-download-and-set-up-meta-llama-3-models-on-hpc-adroit" class="nav-link active" data-scroll-target="#how-to-download-and-set-up-meta-llama-3-models-on-hpc-adroit">How to Download and Set Up Meta LLaMA 3 Models on HPC (Adroit)</a>
  <ul class="collapse">
  <li><a href="#step-1-configure-the-hugging-face-cache-directory" id="toc-step-1-configure-the-hugging-face-cache-directory" class="nav-link" data-scroll-target="#step-1-configure-the-hugging-face-cache-directory">Step 1: Configure the Hugging Face Cache Directory</a></li>
  <li><a href="#step-2-get-authentication-access-from-meta-required-for-llama-models" id="toc-step-2-get-authentication-access-from-meta-required-for-llama-models" class="nav-link" data-scroll-target="#step-2-get-authentication-access-from-meta-required-for-llama-models">Step 2: Get Authentication Access from Meta (Required for LLaMA Models)</a></li>
  <li><a href="#step-3-log-in-to-hugging-face-cli-on-hpc" id="toc-step-3-log-in-to-hugging-face-cli-on-hpc" class="nav-link" data-scroll-target="#step-3-log-in-to-hugging-face-cli-on-hpc">Step 3: Log In to Hugging Face CLI on HPC</a></li>
  <li><a href="#step-4-download-the-llama-3-model-on-the-login-node" id="toc-step-4-download-the-llama-3-model-on-the-login-node" class="nav-link" data-scroll-target="#step-4-download-the-llama-3-model-on-the-login-node">Step 4: Download the LLaMA 3 Model on the Login Node</a></li>
  <li><a href="#step-5-test-the-downloaded-model" id="toc-step-5-test-the-downloaded-model" class="nav-link" data-scroll-target="#step-5-test-the-downloaded-model">Step 5: Test the downloaded Model</a>
  <ul class="collapse">
  <li><a href="#a.-create-a-python-script-for-testing-run_test_llama.py" id="toc-a.-create-a-python-script-for-testing-run_test_llama.py" class="nav-link" data-scroll-target="#a.-create-a-python-script-for-testing-run_test_llama.py">5a. Create a Python script for testing (<code>run_test_llama.py</code>)</a></li>
  <li><a href="#b.-create-a-slurm-job-script-llama3-textgen.slurm" id="toc-b.-create-a-slurm-job-script-llama3-textgen.slurm" class="nav-link" data-scroll-target="#b.-create-a-slurm-job-script-llama3-textgen.slurm">5b. Create a Slurm job script (llama3-textgen.slurm)</a></li>
  </ul></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">LLM to HPC Tutorial</h1>
  <div class="quarto-categories">
    <div class="quarto-category">Coding</div>
    <div class="quarto-category">Tutorial</div>
  </div>
  </div>


<div class="quarto-title-meta-author">
  <div class="quarto-title-meta-heading">Author</div>
  <div class="quarto-title-meta-heading">Affiliation</div>
  
    <div class="quarto-title-meta-contents">
    <p class="author">Steven Mesquiti </p>
  </div>
  <div class="quarto-title-meta-contents">
        <p class="affiliation">
            Princeton University
          </p>
      </div>
  </div>

<div class="quarto-title-meta">

      
  
    
  </div>
  


</header>


<section id="how-to-download-and-set-up-meta-llama-3-models-on-hpc-adroit" class="level1">
<h1>How to Download and Set Up Meta LLaMA 3 Models on HPC (Adroit)</h1>
<p>This guide walks you through configuring your environment, authenticating access, and downloading the LLaMA 3 models from Hugging Face on the Adroit HPC system. It assumes you have basic familiarity with command line, Python, and HPC usage.</p>
<p>This process is infinitely easier if you have connected <code>VSCode</code> to the adroit cluster. <a href="https://researchcomputing.princeton.edu/support/knowledge-base/vs-code">Here</a> is some info on that. IT also runs help sessions on this, which are very useful.</p>
<section id="step-1-configure-the-hugging-face-cache-directory" class="level2">
<h2 class="anchored" data-anchor-id="step-1-configure-the-hugging-face-cache-directory">Step 1: Configure the Hugging Face Cache Directory</h2>
<p>By default, Hugging Face stores downloaded models in your home directory (e.g., <code>/home/username/.cache/huggingface</code>), which may have limited storage on HPC systems. Redirect the cache to your scratch directory for ample space.</p>
<p>You can do that by using the <code>checkquota</code> command in the terminal to find out how much space you have in your scratch directory.</p>
<ol type="1">
<li><strong>Set the environment variable <code>HF_HOME</code> to your scratch directory:</strong></li>
</ol>
<p>On the <strong>Adroit login node</strong>, run this command to append the export statement to your <code>.bashrc</code>:</p>
<pre><code>echo "export HF_HOME=/scratch/network/$USER/.cache/huggingface/" &gt;&gt; $HOME/.bashrc</code></pre>
<ol start="2" type="1">
<li><strong>Reload your shell configuration:</strong></li>
</ol>
<pre><code>source ~/.bashrc</code></pre>
<ol start="3" type="1">
<li><strong>Verify the variable is set:</strong></li>
</ol>
<pre><code>echo $HF_HOME</code></pre>
<p>The excpected output should be:</p>
<pre><code>/scratch/network/&lt;YourNetID&gt;/.cache/huggingface/</code></pre>
</section>
<section id="step-2-get-authentication-access-from-meta-required-for-llama-models" class="level2">
<h2 class="anchored" data-anchor-id="step-2-get-authentication-access-from-meta-required-for-llama-models">Step 2: Get Authentication Access from Meta (Required for LLaMA Models)</h2>
<p>Meta requires users to accept a license and gain explicit access to the LLaMA 3 models on Hugging Face. So, this means you‚Äôll need sign up for a <a href="https://huggingface.co/join">Hugging Face account</a> and request access to the LLaMA 3 models.</p>
<ol type="1">
<li><p>Go to the LLaMA 3 model page on Hugging Face: https://huggingface.co/meta-llama/Llama-3.1-8B (or whatever model you want access to)</p></li>
<li><p>Log in or create a Hugging Face account if you haven‚Äôt already.</p></li>
<li><p>Accept the model license terms: Click the ‚ÄúAccess repository‚Äù button and agree to the license to request access.</p></li>
<li><p>Wait for access to be granted. This should be relatively quick, but may take a few minutes to a few hours depending on demand.</p></li>
</ol>
</section>
<section id="step-3-log-in-to-hugging-face-cli-on-hpc" class="level2">
<h2 class="anchored" data-anchor-id="step-3-log-in-to-hugging-face-cli-on-hpc">Step 3: Log In to Hugging Face CLI on HPC</h2>
<p>Once access is granted, authenticate your HPC environment to allow downloading protected models.</p>
<ol type="1">
<li><strong>Log in to Hugging Face CLI:</strong></li>
</ol>
<p>On the <strong>Adroit login node</strong>, run the following command:</p>
<pre><code>huggingface-cli login</code></pre>
<ol start="2" type="1">
<li><strong>Enter your Hugging Face token:</strong></li>
</ol>
<p>You will be prompted to enter your Hugging Face access token. You can find this token in your Hugging Face account settings under ‚ÄúAccess Tokens‚Äù. Copy and paste it into the terminal when prompted. Make sure not to share this with anyone since this is a personal access token that allows downloading models.</p>
</section>
<section id="step-4-download-the-llama-3-model-on-the-login-node" class="level2">
<h2 class="anchored" data-anchor-id="step-4-download-the-llama-3-model-on-the-login-node">Step 4: Download the LLaMA 3 Model on the Login Node</h2>
<p>Now that you have authenticated, you can download the LLaMA 3 model to your scratch directory.</p>
<ol type="1">
<li><strong>Create a Python script download_llama3.py with this content:</strong></li>
</ol>
<p>Make sure to replace <code>meta-llama/Llama-3.1-8B</code> with the specific model you want<br>
to download if different. Also, make sure you have <code>transformers</code> installed in your Python environment.</p>
<pre><code>from transformers import AutoTokenizer, AutoModelForCausalLM

model_id = "meta-llama/Llama-3.1-8B"
cache_path = "/scratch/network/sm9518/.cache/huggingface"  # replace with your actual NetID

# Download model and tokenizer to cache
AutoTokenizer.from_pretrained(model_id, cache_dir=cache_path)
AutoModelForCausalLM.from_pretrained(model_id, cache_dir=cache_path)

print(f"{model_id} Downloaded Successfully! to {cache_path}")</code></pre>
<ol start="2" type="1">
<li><strong>Run the script on the login node:</strong></li>
</ol>
<pre><code>python download_llama3.py</code></pre>
<ol start="3" type="1">
<li><strong>This will download all necessary model files into your scratch cache directory set by HF_HOME.</strong></li>
</ol>
</section>
<section id="step-5-test-the-downloaded-model" class="level2">
<h2 class="anchored" data-anchor-id="step-5-test-the-downloaded-model">Step 5: Test the downloaded Model</h2>
<p>Now that you have downloaded the LLaMA 3 model to your scratch directory, you can run inference on an HPC compute node.</p>
<section id="a.-create-a-python-script-for-testing-run_test_llama.py" class="level3">
<h3 class="anchored" data-anchor-id="a.-create-a-python-script-for-testing-run_test_llama.py">5a. Create a Python script for testing (<code>run_test_llama.py</code>)</h3>
<p>Save the following code to <code>/scratch/network/$USER/python_test/run_test_llama.py</code>. This script loads the model and runs a short text generation example using the transformers pipeline API.</p>
<pre><code>from transformers import pipeline
import torch
import os

print(f"CUDA Available: {torch.cuda.is_available()}")

if not torch.cuda.is_available():
    raise ValueError(
        "CUDA is not available. Make sure you are running this on a GPU node. "
        "For example, run with Slurm requesting GPU:\n\n"
        "\tsalloc -t 0:10:00 --ntasks=1 --gres=gpu:1 python run_test_llama.py"
    )

model_path = "/scratch/network/$USER/.cache/huggingface/models--meta-llama--Llama-3.1-8B/snapshots/d04e592bb4f6aa9cfee91e2e20afa771667e1d4b"

print("CUDA_VISIBLE_DEVICES =", os.environ.get("CUDA_VISIBLE_DEVICES"))

pipe = pipeline("text-generation", model=model_path, tokenizer=model_path)

prompt = "You are an expert psychologist. Tell me something interesting about psychology regarding Erik Nook's research:"
output = pipe(prompt, max_new_tokens=50)

print("\nModel output:\n", output)</code></pre>
<blockquote class="blockquote">
<p>Make sure to replace $USER in the path with your actual NetID or use a variable if running programmatically.</p>
</blockquote>
</section>
<section id="b.-create-a-slurm-job-script-llama3-textgen.slurm" class="level3">
<h3 class="anchored" data-anchor-id="b.-create-a-slurm-job-script-llama3-textgen.slurm">5b. Create a Slurm job script (llama3-textgen.slurm)</h3>
<p>This Slurm batch script requests one A100 GPU on the Adroit cluster and runs the above Python test script.</p>
<pre><code>#!/bin/bash
#SBATCH --job-name=llama3-textgen           # Job name
#SBATCH --nodes=1                           # Use one node
#SBATCH --ntasks=1                          # One task
#SBATCH --cpus-per-task=1                   # One CPU core
#SBATCH --mem=36G                          # Memory request # can be ess
#SBATCH --gres=gpu:1                        # Request 1 GPU
#SBATCH --time=00:10:00                     # Max runtime (adjust as needed)
#SBATCH --constraint=a100                   # Use A100 GPU
#SBATCH --nodelist=adroit-h11g1             # Run on node with free GPUs
#SBATCH --mail-type=ALL                     # Email on start, end, fail
#SBATCH --mail-user=sm9518@princeton.edu   # Your email

module purge
module load anaconda3/2024.6
module load cudatoolkit/11.8 

source activate talkspaceMADS

cd /scratch/network/$USER/python_test

echo "Job started at $(date)"

export PYTORCH_CUDA_ALLOC_CONF=expandable_segments:True

python run_test_llama.py

echo "Job completed at $(date)"</code></pre>
<blockquote class="blockquote">
<p><strong>üí° Check GPU Node Usage Before Selecting a Node or GPU.</strong></p>
<p>Before submitting your job or manually specifying a GPU node (e.g., with <code>#SBATCH --nodelist=adroit-h11g1</code>).</p>
<p>It‚Äôs a good idea to check which nodes and GPUs have free memory or are under low load. Otherwise, your job might be assigned to a GPU that is already fully used, causing CUDA out-of-memory errors.</p>
</blockquote>
<p>On Adroit, you can use commands like these from the login node to check GPU availability:</p>
<pre><code># Show GPU status and free GPUs per node 
shownodes -p gpu</code></pre>
<p>If you don‚Äôt specify a node, Slurm will pick one for you, but it might not always be the best choice if GPUs on that node are busy.</p>


</section>
</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "Óßã";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
<p>¬© 2026 Steven Mesquiti</p>
</div>   
    <div class="nav-footer-center">
      &nbsp;
    </div>
    <div class="nav-footer-right">
<p><a href="LICENSE">MIT License</a></p>
</div>
  </div>
</footer>




</body></html>